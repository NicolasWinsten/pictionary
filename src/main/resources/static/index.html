<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pictionary</title>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/@stomp/stompjs@7.2.0/bundles/stomp.umd.min.js"></script>
    <style>
      :root {
        --ink: #1c2430;
        --mint: #baf3d1;
        --sky: #d7ecff;
        --accent: #e4572e;
      }
      body {
        margin: 0;
        font-family: "Fira Sans", "Segoe UI", sans-serif;
        color: var(--ink);
        background: radial-gradient(circle at 20% 20%, var(--mint), transparent 45%),
          radial-gradient(circle at 80% 0%, var(--sky), transparent 45%),
          #f6f7fb;
      }
      .wrap {
        max-width: 900px;
        margin: 0 auto;
        padding: 48px 20px;
      }
      h1 {
        font-size: 48px;
        letter-spacing: -0.02em;
        margin-bottom: 12px;
      }
      .card {
        background: #fff;
        border-radius: 20px;
        padding: 24px;
        box-shadow: 0 12px 30px rgba(28, 36, 48, 0.12);
      }
      .row {
        display: flex;
        gap: 16px;
        align-items: center;
        flex-wrap: wrap;
      }
      button {
        background: var(--accent);
        color: #fff;
        border: 0;
        padding: 10px 16px;
        border-radius: 12px;
        font-weight: 600;
        cursor: pointer;
      }
      .pill {
        padding: 6px 12px;
        border-radius: 999px;
        background: var(--mint);
        font-weight: 600;
      }
      .note {
        opacity: 0.8;
      }
      .canvas-wrap {
        margin-top: 20px;
        display: inline-grid;
        gap: 12px;
        align-self: stretch;
        flex: 1 1 0;
      }
      .game-row {
        display: flex;
        align-items: stretch;
        gap: 20px;
        flex-wrap: nowrap;
      }
      .player-panel {
        min-width: 260px;
        flex: 0 0 320px;
        background: #fff;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 8px 24px rgba(28, 36, 48, 0.1);
        align-self: stretch;
        display: flex;
        min-height: 0;
        overflow: hidden;
      }
      @media (max-width: 900px) {
        .game-row {
          flex-wrap: wrap;
        }
        .player-panel {
          flex: 1 1 100%;
        }
      }
      .lobby-info {
        display: flex;
        align-items: stretch;
        gap: 16px;
        flex: 1;
      }
      .column {
        min-width: 160px;
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
      }
      .player-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 8px;
        flex: 0 0 auto;
      }
      .player-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 6px 10px;
        border-radius: 10px;
        background: #f6f7fb;
        font-weight: 600;
      }
      .player-name.ready {
        color: #2a8f4a;
      }
      .player-item.drawing {
        font-weight: bold;
        background-color: #baf3d1;
      }
      .ready-button {
        margin-top: auto;
        width: 100%;
        background: #2a8f4a;
      }
      .ready-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .canvas-box {
        border: 1px solid #d8e0ea;
        border-radius: 12px;
        background: #f8fbff;
        padding: 8px;
        width: fit-content;
      }
      .canvas-disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      canvas {
        display: block;
        border-radius: 8px;
        background: #f8fbff;
        touch-action: none;
      }
      .canvas-tools {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .guess-bar {
        flex: 1;
        display: flex;
        gap: 10px;
      }
      .guess-input {
        width: 100%;
        border: 1px solid #d8e0ea;
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 15px;
        background: #fff;
      }
      .chat-box {
        margin-top: 12px;
        border: 1px solid #d8e0ea;
        border-radius: 12px;
        padding: 10px;
        background: #f8fbff;
        overflow-y: auto;
        max-height: 400px;
        display: grid;
        gap: 6px;
        flex: 1;
        align-content: start;
        min-height: 0;
      }
      .chat-line {
        font-size: 14px;
      }
      .overlay {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        background: rgba(246, 247, 251, 0.92);
        backdrop-filter: blur(6px);
        z-index: 10;
      }
      .lobby-card {
        width: min(520px, 90vw);
        background: #fff;
        border-radius: 18px;
        padding: 24px;
        box-shadow: 0 18px 40px rgba(28, 36, 48, 0.18);
        display: grid;
        gap: 12px;
        text-align: center;
      }
      .lobby-input {
        /* width: 100%; */
        border: 1px solid #d8e0ea;
        border-radius: 12px;
        padding: 12px 14px;
        font-size: 16px;
      }
      .lobby-actions {
        display: flex;
        justify-content: center;
        gap: 12px;
        flex-wrap: wrap;
      }
    </style>
  </head>
  <body>

    <!-- ============================================================
         LOBBY OVERLAY
         Full-screen overlay shown when the client is not connected.
         Prompts the user to enter a lobby code and connect via WebSocket.
         Hidden once the connection is established.
         ============================================================ -->
    <div class="overlay" x-data="{ lobbyCodeInput: '' }" x-show="!$store.ws.isConnected" x-transition>
      <div class="lobby-card">
        <h2>Join a lobby</h2>
        <p class="note">Enter your lobby code to start.</p>
        <!-- Two-way bind input value to lobbyCodeInput via x-model -->
        <input
          class="lobby-input"
          type="text"
          placeholder="Lobby code"
          x-model.trim="lobbyCodeInput"
          @keydown.enter.prevent="connectLobby($store.ws, lobbyCodeInput)"
        />
        <div class="lobby-actions">
          <button @click="connectLobby($store.ws, lobbyCodeInput)">Connect</button>
          <!-- Displays current WebSocket status (disconnected / connecting / connected / error) -->
          <span class="pill" x-text="$store.ws.wsStatus"></span>
        </div>
      </div>
    </div>

    <!-- ============================================================
         MAIN GAME AREA
         Visible after connection. Contains the drawing canvas,
         player list, and chat/guess panel arranged side-by-side.
         ============================================================ -->
    <div class="wrap">
      <h1>Pictionary</h1>
      <p class="note">Spring Boot + WebSockets + Alpine.js</p>

      <div class="card">
        <div class="game-row">

          <!-- ========== CANVAS PANEL ==========
               Alpine component (canvasPanel) that owns the <canvas> element.
               Handles local drawing via pointer events and renders remote
               draw events received through the "draw-event" custom window event. -->
          <div
            class="canvas-wrap"
            x-data="canvasPanel()"
            x-init="init()"
            @draw-event.window="applyRemoteDraw($event.detail)"
          >
            <!-- Shows the word to draw (only visible to the current drawer) -->
            <div class="pill" x-show="$store.ws.currentWord" x-text="`Draw: ${$store.ws.currentWord}`"></div>
            <div class="canvas-box">
              <!-- Drawing canvas. Disabled (via CSS class) when the player is not the drawer.
                   Pointer events drive local stroke rendering and emit STOMP draw messages. -->
              <canvas
                x-ref="draw"
                :class="{ 'canvas-disabled': !$store.ws.isDrawer }"
                @pointerdown.prevent="pointerDown($event)"
                @pointermove.prevent="pointerMove($event)"
                @pointerup="pointerUp()"
                @pointerleave="pointerUp()"
              ></canvas>
            </div>
            <!-- Canvas toolbar: clear button (drawer only) and guess input (non-drawers).
                 Guesses are sent to the server via STOMP on Enter. -->
            <div class="canvas-tools">
              <button @click="sendClear()">Clear</button>
              <div class="guess-bar" x-data="{ guessText: '' }">
                <input
                  class="guess-input"
                  type="text"
                  x-bind:placeholder="$store.ws.isDrawer ? 'You are drawing' : 'Type a guess and press Enter'"
                  x-model.trim="guessText"
                  x-bind:disabled="$store.ws.isDrawer"
                  @keydown.enter.prevent="submitGuess(guessText, $store.ws); guessText = ''"
                />
              </div>
            </div>
          </div>
          <!-- ========== SIDE PANEL (players + chat) ========== -->
          <aside class="player-panel">
            <div class="lobby-info">

              <!-- ===== PLAYER LIST COLUMN =====
                   Maintains a reactive playerList array. The "player-status"
                   custom event (dispatched from STOMP callbacks) drives updates
                   for joins, leaves, ready state, drawing state, and scores. -->
              <div
                class="column"
                x-data="{ playerList: [] }"
                @player-status.window="handlePlayerStatus(playerList, $event.detail, $store.ws.clientId)"
              >
                <!-- Current lobby code badge -->
                <div class="pill" x-text="`Lobby: ${$store.ws.subscribedLobby || '----'}`"></div>
                <ul class="player-list">
                  <template x-for="(player, index) in playerList" :key="`${player.clientId}-${index}`">
                    <li class="player-item" :class="{ drawing: player.isDrawing }">
                      <span
                        class="player-name"
                        :class="{ ready: player.isReady }"
                        x-text="player.name"
                      ></span>
                      <span>
                        <span class="note" x-show="player.score > 0" x-text="player.score" style="font-weight:700;color:var(--accent)"></span>
                        <span class="note" x-show="isSelf(player, $store.ws.clientId)">(you)</span>
                      </span>
                    </li>
                  </template>
                </ul>
                <!-- Ready button. Disabled once the local player has already readied up.
                     Displays a "(ready/total)" counter. -->
                <button
                  class="ready-button"
                  :disabled="isSelfReady(playerList, $store.ws.clientId)"
                  @click="sendReady($store.ws)"
                >
                  Ready <span x-text="`(${readyCount(playerList)}/${playerList.length})`"></span>
                </button>
              </div>
              <!-- ===== CHAT / GUESSES COLUMN =====
                   Displays incoming guess messages from all players.
                   Auto-scrolls to the bottom when new messages arrive. -->
              <div
                class="column"
                x-data="{ chatMessages: [] }"
                @chat-message.window="handleChatMessage(chatMessages, $event.detail, $refs.chatBox)"
              >
                <div class="pill">Guesses</div>
                <div class="chat-box" x-ref="chatBox">
                  <template x-for="(entry, index) in chatMessages" :key="`${entry.id}-${index}`">
                    <div class="chat-line">
                      <strong x-text="entry.name"></strong>
                      <span x-text="`: ${entry.text}`"></span>
                    </div>
                  </template>
                </div>
              </div>
            </div>
          </aside>
        </div>
      </div>
    </div>
  <script>
    /* ================================================================
       APPLICATION INITIALIZATION
       On Alpine's init event, create the global "ws" store that holds
       all WebSocket/STOMP state shared across components.
       ================================================================ */
    document.addEventListener("alpine:init", () => {
      Alpine.store("ws", createWsStore());
    });

    /**
     * Creates the global Alpine store for WebSocket state.
     * Properties:
     *  - isConnected:     whether the STOMP client is connected
     *  - stompClient:     the StompJs.Client instance
     *  - pendingMessages: messages queued while disconnected
     *  - clientId:        unique persistent ID for this browser tab
     *  - wsStatus:        human-readable connection status string
     *  - subscribedLobby: lobby code currently subscribed to
     *  - subscriptions:   active STOMP subscription objects
     *  - isDrawer:        whether this client is the current drawer
     *  - currentWord:     the word assigned to the drawer (null for guessers)
     * @returns {Object} Alpine reactive store
     */
    function createWsStore() {
      return {
        isConnected: false,
        stompClient: null,
        pendingMessages: [],
        clientId: getClientId(),
        wsStatus: "disconnected",
        subscribedLobby: null,
        subscriptions: [],
        isDrawer: null,
        currentWord: null
      };
    }

    /**
     * Alpine data component for the drawing canvas.
     * Manages local drawing state (pen position, stroke in progress),
     * emits draw events to the server, and applies incoming remote draw events.
     * @returns {Object} Alpine component definition
     */
    function canvasPanel() {
      return {
        ctx: null,
        width: 400,
        height: 400,
        lastPos: null,
        isDrawing: false,
        remotePaths: {},
        init() {
          initCanvas(this, this.$refs);
        },
        pointerDown(event) {
          if (!this.ctx || !this.$store.ws.isDrawer) return;
          this.isDrawing = true;
          const { x, y } = getPos(this.$refs, event);
          this.lastPos = { x, y };
          this.ctx.beginPath();
          this.ctx.moveTo(x, y);
          sendDrawEvent(this.$store.ws,"start", x, y);
        },
        pointerMove(event) {
          if (!this.isDrawing || !this.ctx || !this.$store.ws.isDrawer) return;
          const { x, y } = getPos(this.$refs, event);
          this.ctx.lineTo(x, y);
          this.ctx.stroke();
          this.lastPos = { x, y };
          sendDrawEvent(this.$store.ws,"move", x, y);
        },
        pointerUp() {
          if (this.isDrawing && this.lastPos && this.$store.ws.isDrawer) {
            sendDrawEvent(this.$store.ws,"end", this.lastPos.x, this.lastPos.y);
          }
          this.isDrawing = false;
        },
        sendClear() {
          if (!this.$store.ws.isDrawer) return;
          clearCanvas(this.ctx, this.width, this.height);
          sendDrawEvent(this.$store.ws, "clear", 0, 0);
        },
        applyRemoteDraw(event) {
          if (!this.ctx || !event) {
            return;
          }
          if (event.type === "clear") {
            clearCanvas(this.ctx, this.width, this.height);
            this.remotePaths = {};
            return;
          }
          const key = event.sourceId;
          if (event.type === "start") {
            this.ctx.beginPath();
            this.ctx.moveTo(event.x, event.y);
            this.remotePaths[key] = { x: event.x, y: event.y };
            return;
          }
          if (event.type === "move" && this.remotePaths[key]) {
            this.ctx.lineTo(event.x, event.y);
            this.ctx.stroke();
            this.remotePaths[key] = { x: event.x, y: event.y };
            return;
          }
          if (event.type === "end") {
            delete this.remotePaths[key];
          }
        }
      };
    }


    /**
     * Initializes the <canvas> element: sets CSS/pixel dimensions accounting for
     * device pixel ratio, configures stroke style, and fills with background color.
     * @param {Object} canvasState - The canvasPanel Alpine component state
     * @param {Object} refs        - Alpine $refs containing the "draw" canvas element
     */
    function initCanvas(canvasState, refs) {
      const canvas = refs.draw;
      const dpr = window.devicePixelRatio || 1;
      canvas.style.width = `${canvasState.width}px`;
      canvas.style.height = `${canvasState.height}px`;
      canvas.width = Math.floor(canvasState.width * dpr);
      canvas.height = Math.floor(canvasState.height * dpr);
      canvasState.ctx = canvas.getContext("2d");
      canvasState.ctx.scale(dpr, dpr);
      canvasState.ctx.lineWidth = 2;
      canvasState.ctx.lineCap = "round";
      canvasState.ctx.strokeStyle = "#1c2430";
      clearCanvas(canvasState.ctx, canvasState.width, canvasState.height);
    }
    /** Converts a pointer event's page coordinates to canvas-local coordinates. */
    function getPos(refs, event) {
      const rect = refs.draw.getBoundingClientRect();
      return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
      };
    }
    /** Generates a new random client ID using crypto.randomUUID or a timestamp fallback. */
    function createClientId() {
      if (typeof crypto !== "undefined" && crypto.randomUUID) {
        return crypto.randomUUID();
      }
      return `client-${Date.now()}-${Math.floor(Math.random() * 100000)}`;
    }
    /** Retrieves the client ID from localStorage, or null if not set. */
    function getStoredClientId() {
      if (typeof localStorage === "undefined") {
        return null;
      }
      const stored = localStorage.getItem("clientId");
      return stored && stored.trim() ? stored : null;
    }
    /** Persists the client ID to localStorage for reuse across page reloads. */
    function saveClientId(clientId) {
      if (typeof localStorage === "undefined") {
        return;
      }
      localStorage.setItem("clientId", clientId);
    }
    /** Sends a guess message to the server via STOMP /app/guess endpoint. */
    function submitGuess(text, wsStore) {
      if (!text || !wsStore) {
        return;
      }
      sendStomp(wsStore.stompClient,"/app/guess", { text });
    }
    /** Sends a ready signal to the server via STOMP /app/ready endpoint. */
    function sendReady(wsStore) {
      if (!wsStore) {
        return;
      }
      sendStomp(wsStore.stompClient,"/app/ready", {});
    }
    /**
     * Connects to a lobby. If already connected, sends the lobby join message directly.
     * Otherwise, creates a new SockJS/STOMP client, establishes the connection,
     * subscribes to the lobby's STOMP topics, and then sends the join message.
     * @param {Object} wsStore  - The global Alpine "ws" store
     * @param {string} lobbyCode - The lobby code entered by the user
     */
    function connectLobby(wsStore, lobbyCode) {
      const code = lobbyCode.trim();
      if (!code) {
        wsStore.wsStatus = "code required";
        return;
      }
      if (wsStore.stompClient && wsStore.stompClient.connected) {
        sendStomp(wsStore.stompClient, "/app/lobby", { code, clientId: wsStore.clientId });
        return;
      }
      const stomp = StompJs;
      if (!stomp || !SockJS) {
        wsStore.wsStatus = "stomp unavailable";
        return;
      }
      wsStore.wsStatus = "connecting";
      wsStore.stompClient = new stomp.Client({
        webSocketFactory: () => new SockJS("/ws"),
        reconnectDelay: 3000,
        onConnect: () => {
          wsStore.isConnected = true;
          wsStore.wsStatus = "connected";
          subscribeLobby(wsStore, code);
          flushPending(wsStore);
          sendStomp(wsStore.stompClient, "/app/lobby", { code, clientId: wsStore.clientId });
        },
        onStompError: () => {
          wsStore.isConnected = false;
          wsStore.wsStatus = "error";
        },
        onWebSocketClose: () => {
          wsStore.isConnected = false;
          wsStore.wsStatus = "disconnected";
        }
      });
      wsStore.stompClient.activate();
    }

    /**
     * Subscribes to a STOMP endpoint and registers the callback to be executed when messages are received.
     * */
    function makeStompSubscriber(ws, endpoint, callback) {
      if (!ws.stompClient || !ws.stompClient.connected) {
        console.error("Cannot subscribe to stomp endpoint when client is not connected");
        return;
      }
      const subscription = ws.stompClient.subscribe(endpoint, (message) => {
        let payload = null;
        try {
          payload = JSON.parse(message.body);
        } catch (error) {
          console.error("Failed to parse message body", error);
          return;
        }
        // silently drop the message if this client is not the intended recipient
        if (payload.targetClientId && payload.targetClientId !== ws.clientId) {
          console.log("Received message for different client, ignoring", payload);
          return;
        }
        console.log("Received message on endpoint", endpoint, payload);
        callback(payload);
      });
      ws.subscriptions.push(subscription);
    }

    /**
     * Subscribes to all STOMP topics for a lobby: draw events, player status,
     * chat messages, and word assignments. Unsubscribes from any previous lobby first.
     * Incoming messages are dispatched as custom window events so that Alpine
     * components can react via @event.window directives.
     * @param {Object} wsStore - The global Alpine "ws" store
     * @param {string} code    - The lobby code to subscribe to
     */
    function subscribeLobby(wsStore, code) {
      if (!code) {
        return;
      }
      if (wsStore.subscribedLobby === code && wsStore.subscriptions.length) {
        return;
      }
      wsStore.subscriptions.forEach((sub) => sub.unsubscribe());
      wsStore.subscriptions = [];
      wsStore.subscribedLobby = code;
      wsStore.isDrawer = false;
      wsStore.currentWord = null;
      if (!wsStore.stompClient || !wsStore.stompClient.connected) {
        return;
      }

      // handle draw event messages
      makeStompSubscriber(wsStore, `/topic/lobby/${code}/draw`, payload => { 
        // ignore draw events that originated from this client
        if (payload.sourceId !== wsStore.clientId) {
          dispatchDrawEvent(payload);
        }
      });
      // handle player status messages
      makeStompSubscriber(wsStore, `/topic/lobby/${code}/players`, payload => {
        switch (payload.status) {
          case "joined":
            break;
          case "left":
            break;
          case "ready":
            break;
          case "drawing":
            wsStore.isDrawer = payload.clientId === wsStore.clientId;
            if (!wsStore.isDrawer) {
              wsStore.currentWord = null;
            }
            break;
          case "scored":
            break;
          default:
            console.error("Unknown player status", payload.status);
            return;
        }
        dispatchPlayerStatus(payload);
      });
      // handle chat messages
      makeStompSubscriber(wsStore, `/topic/lobby/${code}/chat`, dispatchChatMessage)
      // handle word assignment messages
      makeStompSubscriber(wsStore, `/topic/lobby/${code}/word`, payload => {
        wsStore.currentWord = payload.word;
      });
    }

    /**
     * Publishes a JSON message to a STOMP destination. If the client is not yet
     * connected, the message is queued in pendingMessages to be flushed later.
     * @param {Object} client      - The StompJs.Client instance (may be null)
     * @param {string} destination - STOMP destination (e.g. "/app/draw")
     * @param {Object} body        - Message payload (will be JSON-stringified)
     */
    function sendStomp(client, destination, body) {
      const payload = JSON.stringify(body);
      if (!client || !client.connected) {
        Alpine.store('ws').pendingMessages.push({ destination, body: payload });
        return;
      }
      client.publish({
        destination,
        body: payload,
        headers: { "content-type": "application/json" }
      });
    }
    
    /** Sends all messages that were queued while the STOMP client was disconnected. */
    function flushPending(wsStore) {
      if (!wsStore.stompClient || !wsStore.stompClient.connected) {
        return;
      }
      while (wsStore.pendingMessages.length) {
        const next = wsStore.pendingMessages.shift();
        wsStore.stompClient.publish({
          destination: next.destination,
          body: next.body,
          headers: { "content-type": "application/json" }
        });
      }
    }
    /** Returns the persisted client ID from localStorage, or creates and stores a new one. */
    function getClientId() {
      // I would try to retrieve the client ID from localStorage
      // but that means I can't test multiple clients in the same browser, which is a pain during development
      // const stored = getStoredClientId();
      // if (stored) return stored;
      const id = createClientId();
      saveClientId(id);
      return id;
    }
    /** Sends a draw event (start/move/end/clear) with coordinates to the server. */
    function sendDrawEvent(wsStore, type, x, y) {
      sendStomp(wsStore.stompClient,"/app/draw", { type, x, y, sourceId: wsStore.clientId });
    }
    /* ================================================================
       EVENT DISPATCHERS
       Bridge between STOMP subscription callbacks and Alpine components.
       Each dispatcher fires a custom window event that Alpine components
       listen to via @event.window directives.
       ================================================================ */

    /** Dispatches a "player-status" custom event to update the player list UI. */
    function dispatchPlayerStatus(payload) {
      window.dispatchEvent(new CustomEvent("player-status", { detail: payload }));
    }
    /** Dispatches a "chat-message" custom event to display a new guess in the chat. */
    function dispatchChatMessage(payload) {
      window.dispatchEvent(new CustomEvent("chat-message", { detail: payload }));
    }
    /** Dispatches a "draw-event" custom event to render a remote player's stroke on the canvas. */
    function dispatchDrawEvent(payload) {
      window.dispatchEvent(new CustomEvent("draw-event", { detail: payload }));
    }
    /* ================================================================
       EVENT HANDLERS
       Called by Alpine components in response to dispatched custom events.
       These update the reactive data arrays that drive the UI.
       ================================================================ */

    /** Appends a new chat message to the list and auto-scrolls to the bottom. */
    function handleChatMessage(chatMessages, payload, chatBoxRef) {
      if (!payload || !payload.text) {
        return;
      }
      chatMessages.push(payload);
      scrollChatToBottom(chatBoxRef);
    }
    /** Scrolls the chat container to the bottom on the next animation frame. */
    function scrollChatToBottom(chatBoxRef) {
      requestAnimationFrame(() => {
        if (chatBoxRef) {
          chatBoxRef.scrollTop = chatBoxRef.scrollHeight;
        }
      });
    }
    /**
     * Updates the reactive player list based on a player status message from the server.
     * Handles these statuses:
     *  - "joined"  : adds a new player entry
     *  - "left"    : removes the player from the list
     *  - "ready"   : marks the player as ready (or adds them if not yet in the list)
     *  - "drawing" : highlights the current drawer and clears other players' drawing state
     *  - "scored"  : updates the player's score
     * @param {Array}  players  - The reactive player list array (mutated in place)
     * @param {Object} payload  - The player status message from the server
     * @param {string} clientId - This client's ID (used to filter targeted messages)
     */
    function handlePlayerStatus(players, payload, clientId) {
      if (!payload || !payload.clientId) {
        console.error("Invalid player status payload", payload);
        return;
      }
      const existing = players.find((p) => p.clientId === payload.clientId);
      switch (payload.status) {
        case "scored":
          if (existing) existing.score = payload.score;
          break;
        case "drawing":
          players.forEach((p) => { p.isDrawing = p.clientId === payload.clientId; });
          break;
        case "left":
          if (existing) players.splice(players.indexOf(existing), 1);
          break;
        case "joined":
          if (!existing && payload.name) {
            players.push({ name: payload.name, clientId: payload.clientId, isReady: false, isDrawing: false, score: 0 });
          }
          break;
        case "ready":
          if (existing) {
            existing.isReady = true;
          } else if (payload.name) {
            players.push({ name: payload.name, clientId: payload.clientId, isReady: true, isDrawing: false, score: 0 });
          }
          break;
        default:
          console.error("Unknown player status", payload.status);
      }
    }

    /** Returns true if the local player has already clicked "Ready". */
    function isSelfReady(playerList, clientId) {
      const selfPlayer = playerList.find((player) => player.clientId === clientId);
      return !!(selfPlayer && selfPlayer.isReady);
    }
    /** Returns true if the given player object belongs to this client. */
    function isSelf(player, clientId) {
      return player && player.clientId === clientId;
    }
    /** Counts how many players in the list have readied up. */
    function readyCount(playerList) {
      return playerList.reduce((count, player) => count + (player.isReady ? 1 : 0), 0);
    }
    /** Clears the canvas and fills it with the default background color. */
    function clearCanvas(canvas_ctx, width, height) {
      if (!canvas_ctx) return;
      canvas_ctx.clearRect(0, 0, width, height);
      canvas_ctx.fillStyle = "#f8fbff";
      canvas_ctx.fillRect(0, 0, width, height);
    }
  </script>
  </body>
</html>
