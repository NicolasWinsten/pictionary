<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pictionary</title>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/@stomp/stompjs@7.2.0/bundles/stomp.umd.min.js"></script>
    <style>
      :root {
        --ink: #1c2430;
        --mint: #baf3d1;
        --sky: #d7ecff;
        --accent: #e4572e;
      }
      body {
        margin: 0;
        font-family: "Fira Sans", "Segoe UI", sans-serif;
        color: var(--ink);
        background: radial-gradient(circle at 20% 20%, var(--mint), transparent 45%),
          radial-gradient(circle at 80% 0%, var(--sky), transparent 45%),
          #f6f7fb;
      }
      .wrap {
        max-width: 900px;
        margin: 0 auto;
        padding: 48px 20px;
      }
      h1 {
        font-size: 48px;
        letter-spacing: -0.02em;
        margin-bottom: 12px;
      }
      .card {
        background: #fff;
        border-radius: 20px;
        padding: 24px;
        box-shadow: 0 12px 30px rgba(28, 36, 48, 0.12);
      }
      .row {
        display: flex;
        gap: 16px;
        align-items: center;
        flex-wrap: wrap;
      }
      button {
        background: var(--accent);
        color: #fff;
        border: 0;
        padding: 10px 16px;
        border-radius: 12px;
        font-weight: 600;
        cursor: pointer;
      }
      .pill {
        padding: 6px 12px;
        border-radius: 999px;
        background: var(--mint);
        font-weight: 600;
      }
      .note {
        opacity: 0.8;
      }
      .canvas-wrap {
        margin-top: 20px;
        display: inline-grid;
        gap: 12px;
        align-self: stretch;
        flex: 1 1 0;
      }
      .game-row {
        display: flex;
        align-items: stretch;
        gap: 20px;
        flex-wrap: nowrap;
      }
      .player-panel {
        min-width: 260px;
        flex: 0 0 320px;
        background: #fff;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 8px 24px rgba(28, 36, 48, 0.1);
        align-self: stretch;
        display: flex;
        min-height: 0;
        overflow: hidden;
      }
      @media (max-width: 900px) {
        .game-row {
          flex-wrap: wrap;
        }
        .player-panel {
          flex: 1 1 100%;
        }
      }
      .lobby-info {
        display: flex;
        align-items: stretch;
        gap: 16px;
        flex: 1;
      }
      .column {
        min-width: 160px;
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
      }
      .player-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 8px;
        flex: 0 0 auto;
      }
      .player-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 6px 10px;
        border-radius: 10px;
        background: #f6f7fb;
        font-weight: 600;
      }
      .player-name.ready {
        color: #2a8f4a;
      }
      .player-name.drawing {
        font-weight: bold;
        text-decoration: underline overline;
      }
      .ready-button {
        margin-top: auto;
        width: 100%;
        background: #2a8f4a;
      }
      .ready-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .canvas-box {
        border: 1px solid #d8e0ea;
        border-radius: 12px;
        background: #f8fbff;
        padding: 8px;
        width: fit-content;
      }
      .canvas-disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      canvas {
        display: block;
        border-radius: 8px;
        background: #f8fbff;
        touch-action: none;
      }
      .canvas-tools {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .guess-bar {
        flex: 1;
        display: flex;
        gap: 10px;
      }
      .guess-input {
        width: 100%;
        border: 1px solid #d8e0ea;
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 15px;
        background: #fff;
      }
      .chat-box {
        margin-top: 12px;
        border: 1px solid #d8e0ea;
        border-radius: 12px;
        padding: 10px;
        background: #f8fbff;
        overflow-y: auto;
        max-height: 400px;
        display: grid;
        gap: 6px;
        flex: 1;
        align-content: start;
        min-height: 0;
      }
      .chat-line {
        font-size: 14px;
      }
      .overlay {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        background: rgba(246, 247, 251, 0.92);
        backdrop-filter: blur(6px);
        z-index: 10;
      }
      .lobby-card {
        width: min(520px, 90vw);
        background: #fff;
        border-radius: 18px;
        padding: 24px;
        box-shadow: 0 18px 40px rgba(28, 36, 48, 0.18);
        display: grid;
        gap: 12px;
        text-align: center;
      }
      .lobby-input {
        width: 100%;
        border: 1px solid #d8e0ea;
        border-radius: 12px;
        padding: 12px 14px;
        font-size: 16px;
      }
      .lobby-actions {
        display: flex;
        justify-content: center;
        gap: 12px;
        flex-wrap: wrap;
      }
    </style>
  </head>
  <body>
    <!-- Lobby card asking for lobby code-->
    <div class="overlay" x-data="{ lobbyCodeInput: '' }" x-show="!$store.ws.isConnected" x-transition>
      <div class="lobby-card">
        <h2>Join a lobby</h2>
        <p class="note">Enter your lobby code to start.</p>
        <!-- Use x-model attribute to bind the input value to the data lobbyCode-->
        <input
          class="lobby-input"
          type="text"
          placeholder="Lobby code"
          x-model.trim="lobbyCodeInput"
          @keydown.enter.prevent="connectLobby($store.ws, lobbyCodeInput)"
        />
        <div class="lobby-actions">
          <button @click="connectLobby($store.ws, lobbyCodeInput)">Connect</button>
          <span class="pill" x-text="$store.ws.wsStatus"></span>
        </div>
      </div>
    </div>

    <div class="wrap">
      <h1>Pictionary</h1>
      <p class="note">Spring Boot + WebSockets + Alpine.js</p>

      <div class="card">
        <div class="game-row">
          <div
            class="canvas-wrap"
            x-data="canvasPanel()"
            x-init="init()"
            @draw-event.window="applyRemoteDraw($event.detail)"
          >
            <div class="pill" x-show="$store.ws.currentWord" x-text="`Draw: ${$store.ws.currentWord}`"></div>
            <div class="canvas-box">
              <canvas
                x-ref="draw"
                :class="{ 'canvas-disabled': !$store.ws.isDrawer }"
                @pointerdown.prevent="pointerDown($event)"
                @pointermove.prevent="pointerMove($event)"
                @pointerup="pointerUp()"
                @pointerleave="pointerUp()"
              ></canvas>
            </div>
            <div class="canvas-tools">
              <button @click="sendClear()">Clear</button>
              <div class="guess-bar" x-data="{ guessText: '' }">
                <input
                  class="guess-input"
                  type="text"
                  x-bind:placeholder="$store.ws.isDrawer ? '' : 'Type a guess and press Enter'"
                  x-model.trim="guessText"
                  x-bind:disabled="$store.ws.isDrawer"
                  @keydown.enter.prevent="submitGuess(guessText, $store.ws); guessText = ''"
                />
              </div>
            </div>
          </div>
          <aside
            class="player-panel"
          >
            <div class="lobby-info">
              <div
                class="column"
                x-data="{ playerList: [] }"
                @player-status.window="handlePlayerStatus(playerList, $event.detail, $store.ws.clientId)"
              >
                <div class="pill" x-text="`Lobby: ${$store.ws.subscribedLobby || '----'}`"></div>
                <ul class="player-list">
                  <template x-for="(player, index) in playerList" :key="`${player.clientId}-${index}`">
                    <li class="player-item">
                      <span
                        class="player-name"
                        :class="{ ready: player.isReady, drawing: player.isDrawing }"
                        x-text="player.name"
                      ></span>
                      <span>
                        <span class="note" x-show="player.score > 0" x-text="player.score" style="font-weight:700;color:var(--accent)"></span>
                        <span class="note" x-show="isSelf(player, $store.ws.clientId)">(you)</span>
                      </span>
                    </li>
                  </template>
                </ul>
                <button
                  class="ready-button"
                  :disabled="isSelfReady(playerList, $store.ws.clientId)"
                  @click="sendReady($store.ws)"
                >
                  Ready <span x-text="`(${readyCount(playerList)}/${playerList.length})`"></span>
                </button>
              </div>
              <div
                class="column"
                x-data="{ chatMessages: [] }"
                @chat-message.window="handleChatMessage(chatMessages, $event.detail, $refs)"
              >
                <div class="pill">Guesses</div>
                <div class="chat-box" x-ref="chatBox">
                  <template x-for="(entry, index) in chatMessages" :key="`${entry.id}-${index}`">
                    <div class="chat-line">
                      <strong x-text="entry.name"></strong>
                      <span x-text="`: ${entry.text}`"></span>
                    </div>
                  </template>
                </div>
              </div>
            </div>
          </aside>
        </div>
      </div>
    </div>
  <script>
    document.addEventListener("alpine:init", () => {
      Alpine.store("ws", createWsStore());
    });

    function createWsStore() {
      return {
        isConnected: false,
        stompClient: null,
        pendingMessages: [],
        clientId: getClientId(),
        wsStatus: "disconnected",
        subscribedLobby: null,
        subscriptions: [],
        isDrawer: null,
        currentWord: null
      };
    }

    function canvasPanel() {
      return {
        ctx: null,
        width: 400,
        height: 400,
        lastPos: null,
        isDrawing: false,
        remotePaths: {},
        init() {
          initCanvas(this, this.$refs);
        },
        pointerDown(event) {
          if (!this.ctx || !this.$store.ws.isDrawer) return;
          this.isDrawing = true;
          const { x, y } = getPos(this.$refs, event);
          this.lastPos = { x, y };
          this.ctx.beginPath();
          this.ctx.moveTo(x, y);
          sendDrawEvent(this.$store.ws,"start", x, y);
        },
        pointerMove(event) {
          if (!this.isDrawing || !this.ctx || !this.$store.ws.isDrawer) return;
          const { x, y } = getPos(this.$refs, event);
          this.ctx.lineTo(x, y);
          this.ctx.stroke();
          this.lastPos = { x, y };
          sendDrawEvent(this.$store.ws,"move", x, y);
        },
        pointerUp() {
          if (this.isDrawing && this.lastPos && this.$store.ws.isDrawer) {
            sendDrawEvent(this.$store.ws,"end", this.lastPos.x, this.lastPos.y);
          }
          this.isDrawing = false;
        },
        sendClear() {
          if (!this.$store.ws.isDrawer) return;
          clearCanvas(this.ctx, this.width, this.height);
          sendDrawEvent(this.$store.ws, "clear", 0, 0);
        },
        applyRemoteDraw(event) {
          if (!this.ctx || !event) {
            return;
          }
          if (event.type === "clear") {
            clearCanvas(this.ctx, this.width, this.height);
            this.remotePaths = {};
            return;
          }
          const key = event.sourceId;
          if (event.type === "start") {
            this.ctx.beginPath();
            this.ctx.moveTo(event.x, event.y);
            this.remotePaths[key] = { x: event.x, y: event.y };
            return;
          }
          if (event.type === "move" && this.remotePaths[key]) {
            this.ctx.lineTo(event.x, event.y);
            this.ctx.stroke();
            this.remotePaths[key] = { x: event.x, y: event.y };
            return;
          }
          if (event.type === "end") {
            delete this.remotePaths[key];
          }
        }
      };
    }


    function initCanvas(canvasState, refs) {
      const canvas = refs.draw;
      const dpr = window.devicePixelRatio || 1;
      canvas.style.width = `${canvasState.width}px`;
      canvas.style.height = `${canvasState.height}px`;
      canvas.width = Math.floor(canvasState.width * dpr);
      canvas.height = Math.floor(canvasState.height * dpr);
      canvasState.ctx = canvas.getContext("2d");
      canvasState.ctx.scale(dpr, dpr);
      canvasState.ctx.lineWidth = 2;
      canvasState.ctx.lineCap = "round";
      canvasState.ctx.strokeStyle = "#1c2430";
      clearCanvas(canvasState.ctx, canvasState.width, canvasState.height);
    }
    function getPos(refs, event) {
      const rect = refs.draw.getBoundingClientRect();
      return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
      };
    }
    function createClientId() {
      if (typeof crypto !== "undefined" && crypto.randomUUID) {
        return crypto.randomUUID();
      }
      return `client-${Date.now()}-${Math.floor(Math.random() * 100000)}`;
    }
    function getStoredClientId() {
      if (typeof localStorage === "undefined") {
        return null;
      }
      const stored = localStorage.getItem("clientId");
      return stored && stored.trim() ? stored : null;
    }
    function saveClientId(clientId) {
      if (typeof localStorage === "undefined") {
        return;
      }
      localStorage.setItem("clientId", clientId);
    }
    function submitGuess(text, wsStore) {
      if (!text || !wsStore) {
        return;
      }
      sendStomp(wsStore.stompClient,"/app/guess", { text });
    }
    function sendReady(wsStore) {
      if (!wsStore) {
        return;
      }
      sendStomp(wsStore.stompClient,"/app/ready", {});
    }
    function connectLobby(wsStore, lobbyCode) {
      const code = lobbyCode.trim();
      if (!code) {
        wsStore.wsStatus = "code required";
        return;
      }
      if (wsStore.stompClient && wsStore.stompClient.connected) {
        sendStomp(wsStore.stompClient, "/app/lobby", { code, clientId: wsStore.clientId });
        return;
      }
      const stomp = StompJs;
      if (!stomp || !SockJS) {
        wsStore.wsStatus = "stomp unavailable";
        return;
      }
      wsStore.wsStatus = "connecting";
      wsStore.stompClient = new stomp.Client({
        webSocketFactory: () => new SockJS("/ws"),
        reconnectDelay: 3000,
        onConnect: () => {
          wsStore.isConnected = true;
          wsStore.wsStatus = "connected";
          subscribeLobby(wsStore, code);
          flushPending(wsStore);
          sendStomp(wsStore.stompClient, "/app/lobby", { code, clientId: wsStore.clientId });
        },
        onStompError: () => {
          wsStore.isConnected = false;
          wsStore.wsStatus = "error";
        },
        onWebSocketClose: () => {
          wsStore.isConnected = false;
          wsStore.wsStatus = "disconnected";
        }
      });
      wsStore.stompClient.activate();
    }

    /**
     * Subscribes to a STOMP endpoint and registers the callback to be executed when messages are received.
     * */
    function makeStompSubscriber(ws, endpoint, callback) {
      if (!ws.stompClient || !ws.stompClient.connected) {
        console.error("Cannot subscribe to stomp endpoint when client is not connected");
        return;
      }
      const subscription = ws.stompClient.subscribe(endpoint, (message) => {
        let payload = null;
        try {
          payload = JSON.parse(message.body);
        } catch (error) {
          console.error("Failed to parse message body", error);
          return;
        }
        // silently drop the message if this client is not the intended recipient
        if (payload.targetClientId && payload.targetClientId !== ws.clientId) {
          return;
        }
        console.log("Received message on endpoint", endpoint, payload);
        callback(payload);
      });
      ws.subscriptions.push(subscription);
    }

    function subscribeLobby(wsStore, code) {
      if (!code) {
        return;
      }
      if (wsStore.subscribedLobby === code && wsStore.subscriptions.length) {
        return;
      }
      wsStore.subscriptions.forEach((sub) => sub.unsubscribe());
      wsStore.subscriptions = [];
      wsStore.subscribedLobby = code;
      wsStore.isDrawer = false;
      wsStore.currentWord = null;
      if (!wsStore.stompClient || !wsStore.stompClient.connected) {
        return;
      }

      // handle draw event messages
      makeStompSubscriber(wsStore, `/topic/lobby/${code}/draw`, payload => { 
        // ignore draw events that originated from this client
        if (payload.sourceId !== wsStore.clientId) {
          dispatchDrawEvent(payload);
        }
      });
      // handle player status messages
      makeStompSubscriber(wsStore, `/topic/lobby/${code}/players`, payload => {
        switch (payload.status) {
          case "joined":
            break;
          case "left":
            break;
          case "ready":
            break;
          case "drawing":
            wsStore.isDrawer = payload.clientId === wsStore.clientId;
            if (!wsStore.isDrawer) {
              wsStore.currentWord = null;
            }
            break;
          case "scored":
            break;
          default:
            console.error("Unknown player status", payload.status);
            return;
        }
        dispatchPlayerStatus(payload);
      });
      // handle chat messages
      makeStompSubscriber(wsStore, `/topic/lobby/${code}/chat`, dispatchChatMessage)
      // handle word assignment messages
      makeStompSubscriber(wsStore, `/topic/lobby/${code}/word`, payload => {
        wsStore.currentWord = payload.word;
      });
    }

    function sendStomp(client, destination, body) {
      const payload = JSON.stringify(body);
      if (!client || !client.connected) {
        Alpine.store('ws').pendingMessages.push({ destination, body: payload });
        return;
      }
      client.publish({
        destination,
        body: payload,
        headers: { "content-type": "application/json" }
      });
    }
    
    function flushPending(wsStore) {
      if (!wsStore.stompClient || !wsStore.stompClient.connected) {
        return;
      }
      while (wsStore.pendingMessages.length) {
        const next = wsStore.pendingMessages.shift();
        wsStore.stompClient.publish({
          destination: next.destination,
          body: next.body,
          headers: { "content-type": "application/json" }
        });
      }
    }
    function getClientId() {
      const stored = getStoredClientId();
      if (stored) return stored;
      const id = createClientId();
      saveClientId(id);
      return id;
    }
    function sendDrawEvent(wsStore, type, x, y) {
      sendStomp(wsStore.stompClient,"/app/draw", { type, x, y, sourceId: wsStore.clientId });
    }
    function dispatchPlayerStatus(payload) {
      window.dispatchEvent(new CustomEvent("player-status", { detail: payload }));
    }
    function dispatchChatMessage(payload) {
      window.dispatchEvent(new CustomEvent("chat-message", { detail: payload }));
    }
    function dispatchDrawEvent(payload) {
      window.dispatchEvent(new CustomEvent("draw-event", { detail: payload }));
    }
    function handleChatMessage(chatMessages, payload, refs) {
      if (!payload || !payload.text) {
        return;
      }
      chatMessages.push(payload);
      scrollChatToBottom(refs);
    }
    function scrollChatToBottom(refs) {
      requestAnimationFrame(() => {
        if (refs.chatBox) {
          refs.chatBox.scrollTop = refs.chatBox.scrollHeight;
        }
      });
    }
    /**
     * Updates the player list based on player status message received from server
     * */
    function handlePlayerStatus(players, payload, clientId) {
      // why would this happen?
      if (!payload || !payload.clientId) {
        console.error("Invalid player status payload", payload);
        return;
      }
      if (payload.status === "scored") {
        const scoredPlayer = players.find((player) => player.clientId === payload.clientId);
        if (scoredPlayer) {
          scoredPlayer.score = payload.score;
        }
        return;
      }
      if (payload.status === "drawing") {
        players.forEach((player) => {
          player.isDrawing = player.clientId === payload.clientId;
        });
        return;
      }
      if (payload.status === "ready") {
        const existing = players.find((player) => player.clientId === payload.clientId);
        if (existing) {
          existing.isReady = true;
          return;
        }
      }
      if (payload.status === "left") {
        const leftPlayerIndex = players.findIndex((player) => player.clientId === payload.clientId);
        if (leftPlayerIndex !== -1) {
          players.splice(leftPlayerIndex, 1);
        }
        return;
      }
      if (!payload.name) {
        return;
      }
      if (payload.targetClientId && payload.targetClientId !== clientId) {
        return;
      }
      const existing = players.find((player) => player.clientId === payload.clientId);
      if (payload.status === "joined" && !existing) {
        players.push({ name: payload.name, clientId: payload.clientId, isReady: false, isDrawing: false, score: 0 });
        return;
      }
      if (payload.status === "ready") {
        if (existing) {
          existing.isReady = true;
        } else {
          players.push({ name: payload.name, clientId: payload.clientId, isReady: true, isDrawing: false, score: 0 });
        }
      }
    }
    
    function isSelfReady(playerList, clientId) {
      const selfPlayer = playerList.find((player) => player.clientId === clientId);
      return !!(selfPlayer && selfPlayer.isReady);
    }
    function isSelf(player, clientId) {
      return player && player.clientId === clientId;
    }
    function readyCount(playerList) {
      return playerList.reduce((count, player) => count + (player.isReady ? 1 : 0), 0);
    }
    function clearCanvas(canvas_ctx, width, height) {
      if (!canvas_ctx) return;
      canvas_ctx.clearRect(0, 0, width, height);
      canvas_ctx.fillStyle = "#f8fbff";
      canvas_ctx.fillRect(0, 0, width, height);
    }
  </script>
  </body>
</html>
